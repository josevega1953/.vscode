"use strict";exports.id=834,exports.ids=[834],exports.modules={99834(e,t,r){function n(e){return(e instanceof Buffer?e:Buffer.from(e.buffer)).toString("base64")}function o(e){return Buffer.from(e,"base64")}r.d(t,{ServiceClient:()=>q,fj:()=>T,rl:()=>p});const s="$",i="_",a=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,l=/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;function c(e,t){const r=e.parsedHeaders;if("HEAD"===e.request.method)return{...r,body:e.parsedBody};const n=t&&t.bodyMapper,o=Boolean(n?.nullable),s=n?.type.name;if("Stream"===s)return{...r,blobBody:e.blobBody,readableStreamBody:e.readableStreamBody};const i="Composite"===s&&n.type.modelProperties||{},a=Object.keys(i).some(e=>""===i[e].serializedName);if("Sequence"===s||a){const t=e.parsedBody??[];for(const r of Object.keys(i))i[r].serializedName&&(t[r]=e.parsedBody?.[r]);if(r)for(const e of Object.keys(r))t[e]=r[e];return!o||e.parsedBody||r||0!==Object.getOwnPropertyNames(i).length?t:null}return function(e){const t={...e.headers,...e.body};return e.hasNullableType&&0===Object.getOwnPropertyNames(t).length?e.shouldWrapBody?{body:null}:null:e.shouldWrapBody?{...e.headers,body:e.body}:t}({body:e.parsedBody,headers:r,hasNullableType:o,shouldWrapBody:(l=e.parsedBody,c=s,"Composite"!==c&&"Dictionary"!==c&&("string"==typeof l||"number"==typeof l||"boolean"==typeof l||null!==c?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)||null==l))});var l,c}class u{modelMappers;isXML;constructor(e={},t=!1){this.modelMappers=e,this.isXML=t}validateConstraints(e,t,r){const n=(e,n)=>{throw new Error(`"${r}" with value "${t}" should satisfy the constraint "${e}": ${n}.`)};if(e.constraints&&null!=t){const{ExclusiveMaximum:r,ExclusiveMinimum:o,InclusiveMaximum:s,InclusiveMinimum:i,MaxItems:a,MaxLength:l,MinItems:c,MinLength:u,MultipleOf:p,Pattern:f,UniqueItems:m}=e.constraints;if(void 0!==r&&t>=r&&n("ExclusiveMaximum",r),void 0!==o&&t<=o&&n("ExclusiveMinimum",o),void 0!==s&&t>s&&n("InclusiveMaximum",s),void 0!==i&&t<i&&n("InclusiveMinimum",i),void 0!==a&&t.length>a&&n("MaxItems",a),void 0!==l&&t.length>l&&n("MaxLength",l),void 0!==c&&t.length<c&&n("MinItems",c),void 0!==u&&t.length<u&&n("MinLength",u),void 0!==p&&t%p!==0&&n("MultipleOf",p),f){const e="string"==typeof f?new RegExp(f):f;"string"==typeof t&&null!==t.match(e)||n("Pattern",f)}m&&t.some((e,t,r)=>r.indexOf(e)!==t)&&n("UniqueItems",m)}}serialize(e,t,r,o={xml:{}}){const c={xml:{rootName:o.xml.rootName??"",includeRoot:o.xml.includeRoot??!1,xmlCharKey:o.xml.xmlCharKey??i}};let u={};const p=e.type.name;r||(r=e.serializedName),null!==p.match(/^Sequence$/i)&&(u=[]),e.isConstant&&(t=e.defaultValue);const{required:h,nullable:x}=e;if(h&&x&&void 0===t)throw new Error(`${r} cannot be undefined.`);if(h&&!x&&null==t)throw new Error(`${r} cannot be null or undefined.`);if(!h&&!1===x&&null===t)throw new Error(`${r} cannot be null.`);return null==t||null!==p.match(/^any$/i)?u=t:null!==p.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i)?u=function(e,t,r){if(null!=r)if(null!==e.match(/^Number$/i)){if("number"!=typeof r)throw new Error(`${t} with value ${r} must be of type number.`)}else if(null!==e.match(/^String$/i)){if("string"!=typeof r.valueOf())throw new Error(`${t} with value "${r}" must be of type string.`)}else if(null!==e.match(/^Uuid$/i)){if("string"!=typeof r.valueOf()||(n=r,!l.test(n)))throw new Error(`${t} with value "${r}" must be of type string and a valid uuid.`)}else if(null!==e.match(/^Boolean$/i)){if("boolean"!=typeof r)throw new Error(`${t} with value ${r} must be of type boolean.`)}else if(null!==e.match(/^Stream$/i)){const e=typeof r;if(!("string"===e||"function"==typeof r.pipe||"function"==typeof r.tee||r instanceof ArrayBuffer||ArrayBuffer.isView(r)||("function"==typeof Blob||"object"==typeof Blob)&&r instanceof Blob||"function"===e))throw new Error(`${t} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`)}var n;return r}(p,r,t):null!==p.match(/^Enum$/i)?u=function(e,t,r){if(!t)throw new Error(`Please provide a set of allowedValues to validate ${e} as an Enum Type.`);if(!t.some(e=>"string"==typeof e.valueOf()?e.toLowerCase()===r.toLowerCase():e===r))throw new Error(`${r} is not a valid value for ${e}. The valid values are: ${JSON.stringify(t)}.`);return r}(r,e.type.allowedValues,t):null!==p.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i)?u=function(e,t,r){if(null!=t)if(null!==e.match(/^Date$/i)){if(!(t instanceof Date||"string"==typeof t.valueOf()&&!isNaN(Date.parse(t))))throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);t=t instanceof Date?t.toISOString().substring(0,10):new Date(t).toISOString().substring(0,10)}else if(null!==e.match(/^DateTime$/i)){if(!(t instanceof Date||"string"==typeof t.valueOf()&&!isNaN(Date.parse(t))))throw new Error(`${r} must be an instanceof Date or a string in ISO8601 format.`);t=t instanceof Date?t.toISOString():new Date(t).toISOString()}else if(null!==e.match(/^DateTimeRfc1123$/i)){if(!(t instanceof Date||"string"==typeof t.valueOf()&&!isNaN(Date.parse(t))))throw new Error(`${r} must be an instanceof Date or a string in RFC-1123 format.`);t=t instanceof Date?t.toUTCString():new Date(t).toUTCString()}else if(null!==e.match(/^UnixTime$/i)){if(!(t instanceof Date||"string"==typeof t.valueOf()&&!isNaN(Date.parse(t))))throw new Error(`${r} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);t=function(e){if(e)return"string"==typeof e.valueOf()&&(e=new Date(e)),Math.floor(e.getTime()/1e3)}(t)}else if(null!==e.match(/^TimeSpan$/i)&&!function(e){return a.test(e)}(t))throw new Error(`${r} must be a string in ISO 8601 format. Instead was "${t}".`);return t}(p,t,r):null!==p.match(/^ByteArray$/i)?u=function(e,t){if(null!=t){if(!(t instanceof Uint8Array))throw new Error(`${e} must be of type Uint8Array.`);t=n(t)}return t}(r,t):null!==p.match(/^Base64Url$/i)?u=function(e,t){if(null!=t){if(!(t instanceof Uint8Array))throw new Error(`${e} must be of type Uint8Array.`);t=function(e){if(e){if(!(e instanceof Uint8Array))throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");return function(e){let t=e.length;for(;t-1>=0&&"="===e[t-1];)--t;return e.substr(0,t)}(n(e)).replace(/\+/g,"-").replace(/\//g,"_")}}(t)}return t}(r,t):null!==p.match(/^Sequence$/i)?u=function(e,t,r,n,o,i){if(!Array.isArray(r))throw new Error(`${n} must be of type Array.`);let a=t.type.element;if(!a||"object"!=typeof a)throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}.`);"Composite"===a.type.name&&a.type.className&&(a=e.modelMappers[a.type.className]??a);const l=[];for(let t=0;t<r.length;t++){const c=e.serialize(a,r[t],n,i);if(o&&a.xmlNamespace){const e=a.xmlNamespacePrefix?`xmlns:${a.xmlNamespacePrefix}`:"xmlns";"Composite"===a.type.name?(l[t]={...c},l[t][s]={[e]:a.xmlNamespace}):(l[t]={},l[t][i.xml.xmlCharKey]=c,l[t][s]={[e]:a.xmlNamespace})}else l[t]=c}return l}(this,e,t,r,Boolean(this.isXML),c):null!==p.match(/^Dictionary$/i)?u=function(e,t,r,n,o,i){if("object"!=typeof r)throw new Error(`${n} must be of type object.`);const a=t.type.value;if(!a||"object"!=typeof a)throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}.`);const l={};for(const t of Object.keys(r)){const s=e.serialize(a,r[t],n,i);l[t]=y(a,s,o,i)}if(o&&t.xmlNamespace){const e=t.xmlNamespacePrefix?`xmlns:${t.xmlNamespacePrefix}`:"xmlns",r=l;return r[s]={[e]:t.xmlNamespace},r}return l}(this,e,t,r,Boolean(this.isXML),c):null!==p.match(/^Composite$/i)&&(u=function(e,t,r,n,o,i){if(g(e,t)&&(t=b(e,t,r,"clientName")),null!=r){const a={},l=d(e,t,n);for(const c of Object.keys(l)){const u=l[c];if(u.readOnly)continue;let p,m=a;if(e.isXML)p=u.xmlIsWrapped?u.xmlName:u.xmlElementName||u.xmlName;else{const e=f(u.serializedName);p=e.pop();for(const t of e){null==m[t]&&(void 0!==r[c]&&null!==r[c]||void 0!==u.defaultValue)&&(m[t]={}),m=m[t]}}if(null!=m){if(o&&t.xmlNamespace){const e=t.xmlNamespacePrefix?`xmlns:${t.xmlNamespacePrefix}`:"xmlns";m[s]={...m[s],[e]:t.xmlNamespace}}const a=""!==u.serializedName?n+"."+u.serializedName:n;let l=r[c];const f=g(e,t);f&&f.clientName===c&&null==l&&(l=t.serializedName);const d=e.serialize(u,l,a,i);if(void 0!==d&&null!=p){const e=y(u,d,o,i);o&&u.xmlIsAttribute?(m[s]=m[s]||{},m[s][p]=d):o&&u.xmlIsWrapped?m[p]={[u.xmlElementName]:e}:m[p]=e}}}const c=function(e,t,r){const n=t.type.additionalProperties;if(!n&&t.type.className){const n=m(e,t,r);return n?.type.additionalProperties}return n}(e,t,n);if(c){const t=Object.keys(l);for(const o in r)t.every(e=>e!==o)&&(a[o]=e.serialize(c,r[o],n+'["'+o+'"]',i))}return a}return r}(this,e,t,r,Boolean(this.isXML),c)),u}deserialize(e,t,r,n={xml:{}}){const a={xml:{rootName:n.xml.rootName??"",includeRoot:n.xml.includeRoot??!1,xmlCharKey:n.xml.xmlCharKey??i},ignoreUnknownProperties:n.ignoreUnknownProperties??!1};if(null==t)return this.isXML&&"Sequence"===e.type.name&&!e.xmlIsWrapped&&(t=[]),void 0!==e.defaultValue&&(t=e.defaultValue),t;let l;const c=e.type.name;if(r||(r=e.serializedName),null!==c.match(/^Composite$/i))l=function(e,t,r,n,o){const a=o.xml.xmlCharKey??i;g(e,t)&&(t=b(e,t,r,"serializedName"));const l=d(e,t,n);let c={};const u=[];for(const i of Object.keys(l)){const p=l[i],m=f(l[i].serializedName);u.push(m[0]);const{serializedName:d,xmlName:y,xmlElementName:h}=p;let b=n;""!==d&&void 0!==d&&(b=n+"."+d);const g=p.headerCollectionPrefix;if(g){const t={};for(const n of Object.keys(r))n.startsWith(g)&&(t[n.substring(g.length)]=e.deserialize(p.type.value,r[n],b,o)),u.push(n);c[i]=t}else if(e.isXML)if(p.xmlIsAttribute&&r[s])c[i]=e.deserialize(p,r[s][y],b,o);else if(p.xmlIsMsText)void 0!==r[a]?c[i]=r[a]:"string"==typeof r&&(c[i]=r);else{const t=h||y||d;if(p.xmlIsWrapped){const t=r[y],n=t?.[h]??[];c[i]=e.deserialize(p,n,b,o),u.push(y)}else{const n=r[t];c[i]=e.deserialize(p,n,b,o),u.push(t)}}else{let n,s=r,a=0;for(const e of m){if(!s)break;a++,s=s[e]}null===s&&a<m.length&&(s=void 0),n=s;const u=t.type.polymorphicDiscriminator;let f;if(u&&i===u.clientName&&null==n&&(n=t.serializedName),Array.isArray(r[i])&&""===l[i].serializedName){n=r[i];const t=e.deserialize(p,n,b,o);for(const[e,r]of Object.entries(c))Object.prototype.hasOwnProperty.call(t,e)||(t[e]=r);c=t}else void 0===n&&void 0===p.defaultValue||(f=e.deserialize(p,n,b,o),c[i]=f)}}const p=t.type.additionalProperties;if(p){const t=e=>{for(const t in l)if(f(l[t].serializedName)[0]===e)return!1;return!0};for(const s in r)t(s)&&(c[s]=e.deserialize(p,r[s],n+'["'+s+'"]',o))}else if(r&&!o.ignoreUnknownProperties)for(const e of Object.keys(r))void 0!==c[e]||u.includes(e)||h(e,o)||(c[e]=r[e]);return c}(this,e,t,r,a);else{if(this.isXML){const e=a.xml.xmlCharKey;void 0!==t[s]&&void 0!==t[e]&&(t=t[e])}null!==c.match(/^Number$/i)?(l=parseFloat(t),isNaN(l)&&(l=t)):null!==c.match(/^Boolean$/i)?l="true"===t||"false"!==t&&t:null!==c.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i)?l=t:null!==c.match(/^(Date|DateTime|DateTimeRfc1123)$/i)?l=new Date(t):null!==c.match(/^UnixTime$/i)?l=function(e){if(e)return new Date(1e3*e)}(t):null!==c.match(/^ByteArray$/i)?l=o(t):null!==c.match(/^Base64Url$/i)?l=function(e){if(e){if(e&&"string"!=typeof e.valueOf())throw new Error("Please provide an input of type string for converting to Uint8Array");return o(e=e.replace(/-/g,"+").replace(/_/g,"/"))}}(t):null!==c.match(/^Sequence$/i)?l=function(e,t,r,n,o){let s=t.type.element;if(!s||"object"!=typeof s)throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${n}`);if(r){Array.isArray(r)||(r=[r]),"Composite"===s.type.name&&s.type.className&&(s=e.modelMappers[s.type.className]??s);const t=[];for(let i=0;i<r.length;i++)t[i]=e.deserialize(s,r[i],`${n}[${i}]`,o);return t}return r}(this,e,t,r,a):null!==c.match(/^Dictionary$/i)&&(l=function(e,t,r,n,o){const s=t.type.value;if(!s||"object"!=typeof s)throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${n}`);if(r){const t={};for(const i of Object.keys(r))t[i]=e.deserialize(s,r[i],n,o);return t}return r}(this,e,t,r,a))}return e.isConstant&&(l=e.defaultValue),l}}function p(e={},t=!1){return new u(e,t)}function f(e){const t=[];let r="";if(e){const n=e.split(".");for(const e of n)"\\"===e.charAt(e.length-1)?r+=e.substr(0,e.length-1)+".":(r+=e,t.push(r),r="")}return t}function m(e,t,r){const n=t.type.className;if(!n)throw new Error(`Class name for model "${r}" is not provided in the mapper "${JSON.stringify(t,void 0,2)}".`);return e.modelMappers[n]}function d(e,t,r){let n=t.type.modelProperties;if(!n){const o=m(e,t,r);if(!o)throw new Error(`mapper() cannot be null or undefined for model "${t.type.className}".`);if(n=o?.type.modelProperties,!n)throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(o)}" of type "${t.type.className}" for object "${r}".`)}return n}function y(e,t,r,n){if(!r||!e.xmlNamespace)return t;const o=e.xmlNamespacePrefix?`xmlns:${e.xmlNamespacePrefix}`:"xmlns",i={[o]:e.xmlNamespace};if(["Composite"].includes(e.type.name)){if(t[s])return t;{const e={...t};return e[s]=i,e}}const a={};return a[n.xml.xmlCharKey]=t,a[s]=i,a}function h(e,t){return[s,t.xml.xmlCharKey].includes(e)}function b(e,t,r,n){const o=g(e,t);if(o){let s=o[n];if(s){"serializedName"===n&&(s=s.replace(/\\/gi,""));const o=r[s],i=t.type.uberParent??t.type.className;if("string"==typeof o&&i){const r=function(e,t,r){const n=[r];for(;n.length;){const r=n.shift(),o=t===r?t:r+"."+t;if(Object.prototype.hasOwnProperty.call(e,o))return e[o];for(const[t,o]of Object.entries(e))t.startsWith(r+".")&&o.type.uberParent===r&&o.type.className&&n.push(o.type.className)}}(e.modelMappers.discriminators,o,i);r&&(t=r)}}}return t}function g(e,t){return t.type.polymorphicDiscriminator||x(e,t.type.uberParent)||x(e,t.type.className)}function x(e,t){return t&&e.modelMappers[t]&&e.modelMappers[t].type.polymorphicDiscriminator}const w="Sequence",$="Stream";var N=r(44835);const S=r(54430).state;function v(e,t,r){let n=t.parameterPath;const o=t.mapper;let s;if("string"==typeof n&&(n=[n]),Array.isArray(n)){if(n.length>0)if(o.isConstant)s=o.defaultValue;else{let t=C(e,n);!t.propertyFound&&r&&(t=C(r,n));let i=!1;t.propertyFound||(i=o.required||"options"===n[0]&&2===n.length),s=i?o.defaultValue:t.propertyValue}}else{o.required&&(s={});for(const t in n){const i=o.type.modelProperties[t],a=v(e,{parameterPath:n[t],mapper:i},r);void 0!==a&&(s||(s={}),s[t]=a)}}return s}function C(e,t){const r={propertyFound:!1};let n=0;for(;n<t.length;++n){const r=t[n];if(!e||!(r in e))break;e=e[r]}return n===t.length&&(r.propertyValue=e,r.propertyFound=!0),r}const z=Symbol.for("@azure/core-client original request");function A(e){if(function(e){return z in e}(e))return A(e[z]);let t=S.operationRequestMap.get(e);return t||(t={},S.operationRequestMap.set(e,t)),t}const O=["application/json","text/json"],P=["application/xml","application/atom+xml"];function M(e){const{parameterPath:t,mapper:r}=e;let n;return n="string"==typeof t?t:Array.isArray(t)?t.join("."):r.serializedName,n}let E;const B={CSV:",",SSV:" ",Multi:"Multi",TSV:"\t",Pipes:"|"};function D(e,t){let r=e;for(const[e,n]of t)r=r.split(e).join(n);return r}const R=(0,r(69325).KV)("core-client");class q{_endpoint;_requestContentType;_allowInsecureConnection;_httpClient;pipeline;constructor(e={}){if(this._requestContentType=e.requestContentType,this._endpoint=e.endpoint??e.baseUri,e.baseUri&&R.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead."),this._allowInsecureConnection=e.allowInsecureConnection,this._httpClient=e.httpClient||(E||(E=(0,N.fl)()),E),this.pipeline=e.pipeline||function(e){const t=function(e){if(e.credentialScopes)return e.credentialScopes;if(e.endpoint)return`${e.endpoint}/.default`;if(e.baseUri)return`${e.baseUri}/.default`;if(e.credential&&!e.credentialScopes)throw new Error("When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy")}(e),r=e.credential&&t?{credentialScopes:t,credential:e.credential}:void 0;return function(e={}){const t=(0,N.Fp)(e??{});return e.credentialOptions&&t.addPolicy((0,N.N$)({credential:e.credentialOptions.credential,scopes:e.credentialOptions.credentialScopes})),t.addPolicy(function(e={}){const t=e.stringifyXML;return{name:"serializationPolicy",async sendRequest(e,r){const n=A(e),o=n?.operationSpec,a=n?.operationArguments;return o&&a&&(function(e,t,r){if(r.headerParameters)for(const n of r.headerParameters){let o=v(t,n);if(null!=o||n.mapper.required){o=r.serializer.serialize(n.mapper,o,M(n));const t=n.mapper.headerCollectionPrefix;if(t)for(const r of Object.keys(o))e.headers.set(t+r,o[r]);else e.headers.set(n.mapper.serializedName||M(n),o)}}const n=t.options?.requestOptions?.customHeaders;if(n)for(const t of Object.keys(n))e.headers.set(t,n[t])}(e,a,o),function(e,t,r,n=function(){throw new Error("XML serialization unsupported!")}){const o=t.options?.serializerOptions,a={xml:{rootName:o?.xml.rootName??"",includeRoot:o?.xml.includeRoot??!1,xmlCharKey:o?.xml.xmlCharKey??i}},l=a.xml.xmlCharKey;if(r.requestBody&&r.requestBody.mapper){e.body=v(t,r.requestBody);const o=r.requestBody.mapper,{required:i,serializedName:c,xmlName:u,xmlElementName:p,xmlNamespace:f,xmlNamespacePrefix:m,nullable:d}=o,y=o.type.name;try{if(void 0!==e.body&&null!==e.body||d&&null===e.body||i){const t=M(r.requestBody);e.body=r.serializer.serialize(o,e.body,t,a);const i=y===$;if(r.isXML){const t=m?`xmlns:${m}`:"xmlns",r=function(e,t,r,n,o){if(e&&!["Composite","Sequence","Dictionary"].includes(r)){const r={};return r[o.xml.xmlCharKey]=n,r[s]={[t]:e},r}return n}(f,t,y,e.body,a);y===w?e.body=n(function(e,t,r,n){if(Array.isArray(e)||(e=[e]),!r||!n)return{[t]:e};const o={[t]:e};return o[s]={[r]:n},o}(r,p||u||c,t,f),{rootName:u||c,xmlCharKey:l}):i||(e.body=n(r,{rootName:u||c,xmlCharKey:l}))}else{if("String"===y&&(r.contentType?.match("text/plain")||"text"===r.mediaType))return;i||(e.body=JSON.stringify(e.body))}}}catch(e){throw new Error(`Error "${e.message}" occurred in serializing the payload - ${JSON.stringify(c,void 0,"  ")}.`)}}else if(r.formDataParameters&&r.formDataParameters.length>0){e.formData={};for(const n of r.formDataParameters){const o=v(t,n);if(null!=o){const t=n.mapper.serializedName||M(n);e.formData[t]=r.serializer.serialize(n.mapper,o,M(n),a)}}}}(e,a,o,t)),r(e)}}}(e.serializationOptions),{phase:"Serialize"}),t.addPolicy(function(e={}){const t=e.expectedContentTypes?.json??O,r=e.expectedContentTypes?.xml??P,n=e.parseXML,o=e.serializerOptions,s={xml:{rootName:o?.xml.rootName??"",includeRoot:o?.xml.includeRoot??!1,xmlCharKey:o?.xml.xmlCharKey??i}};return{name:"deserializationPolicy",async sendRequest(e,o){const i=await o(e);return async function(e,t,r,n,o){const s=await async function(e,t,r,n,o){if(!r.request.streamResponseStatusCodes?.has(r.status)&&r.bodyAsText){const s=r.bodyAsText,i=r.headers.get("Content-Type")||"",a=i?i.split(";").map(e=>e.toLowerCase()):[];try{if(0===a.length||a.some(t=>-1!==e.indexOf(t)))return r.parsedBody=JSON.parse(s),r;if(a.some(e=>-1!==t.indexOf(e))){if(!o)throw new Error("Parsing XML not supported.");const e=await o(s,n.xml);return r.parsedBody=e,r}}catch(e){const t=`Error "${e}" occurred while parsing the response body - ${r.bodyAsText}.`,n=e.code||N.pj.PARSE_ERROR;throw new N.pj(t,{code:n,statusCode:r.status,request:r.request,response:r})}}return r}(e,t,r,n,o);if(!function(e){const t=A(e.request),r=t?.shouldDeserialize;let n;return n=void 0===r||("boolean"==typeof r?r:r(e)),n}(s))return s;const i=A(s.request),a=i?.operationSpec;if(!a||!a.responses)return s;const l=function(e){let t;const r=A(e.request),n=r?.operationSpec;return n&&(t=r?.operationResponseGetter?r?.operationResponseGetter(n,e):n.responses[e.status]),t}(s),{error:c,shouldReturnResponse:u}=function(e,t,r,n){const o=200<=e.status&&e.status<300,s=function(e){const t=Object.keys(e.responses);return 0===t.length||1===t.length&&"default"===t[0]}(t)?o:!!r;if(s){if(!r)return{error:null,shouldReturnResponse:!1};if(!r.isError)return{error:null,shouldReturnResponse:!1}}const i=r??t.responses.default,a=e.request.streamResponseStatusCodes?.has(e.status)?`Unexpected status code: ${e.status}`:e.bodyAsText,l=new N.pj(a,{statusCode:e.status,request:e.request,response:e});if(!(i||e.parsedBody?.error?.code&&e.parsedBody?.error?.message))throw l;const c=i?.bodyMapper,u=i?.headersMapper;try{if(e.parsedBody){const r=e.parsedBody;let o;if(c){let e=r;if(t.isXML&&c.type.name===w){e=[];const t=c.xmlElementName;"object"==typeof r&&t&&(e=r[t])}o=t.serializer.deserialize(c,e,"error.response.parsedBody",n)}const s=r.error||o||r;l.code=s.code,s.message&&(l.message=s.message),c&&(l.response.parsedBody=o)}e.headers&&u&&(l.response.parsedHeaders=t.serializer.deserialize(u,e.headers.toJSON(),"operationRes.parsedHeaders"))}catch(t){l.message=`Error "${t.message}" occurred in deserializing the responseBody - "${e.bodyAsText}" for the default response.`}return{error:l,shouldReturnResponse:!1}}(s,a,l,n);if(c)throw c;if(u)return s;if(l){if(l.bodyMapper){let e=s.parsedBody;a.isXML&&l.bodyMapper.type.name===w&&(e="object"==typeof e?e[l.bodyMapper.xmlElementName]:[]);try{s.parsedBody=a.serializer.deserialize(l.bodyMapper,e,"operationRes.parsedBody",n)}catch(e){throw new N.pj(`Error ${e} occurred in deserializing the responseBody - ${s.bodyAsText}`,{statusCode:s.status,request:s.request,response:s})}}else"HEAD"===a.httpMethod&&(s.parsedBody=r.status>=200&&r.status<300);l.headersMapper&&(s.parsedHeaders=a.serializer.deserialize(l.headersMapper,s.headers.toJSON(),"operationRes.parsedHeaders",{xml:{},ignoreUnknownProperties:!0}))}return s}(t,r,i,s,n)}}}(e.deserializationOptions),{phase:"Deserialize"}),t}({...e,credentialOptions:r})}(e),e.additionalPolicies?.length)for(const{policy:t,position:r}of e.additionalPolicies){const e="perRetry"===r?"Sign":void 0;this.pipeline.addPolicy(t,{afterPhase:e})}}async sendRequest(e){return this.pipeline.sendRequest(this._httpClient,e)}async sendOperationRequest(e,t){const r=t.baseUrl||this._endpoint;if(!r)throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");const n=function(e,t,r,n){const o=function(e,t,r){const n=new Map;if(e.urlParameters?.length)for(const o of e.urlParameters){let s=v(t,o,r);const i=M(o);s=e.serializer.serialize(o.mapper,s,i),o.skipEncoding||(s=encodeURIComponent(s)),n.set(`{${o.mapper.serializedName||i}}`,s)}return n}(t,r,n);let s=!1,i=D(e,o);if(t.path){let e=D(t.path,o);"/{nextLink}"===t.path&&e.startsWith("/")&&(e=e.substring(1)),e.includes("://")?(i=e,s=!0):i=function(e,t){if(!t)return e;const r=new URL(e);let n=r.pathname;n.endsWith("/")||(n=`${n}/`),t.startsWith("/")&&(t=t.substring(1));const o=t.indexOf("?");if(-1!==o){const e=t.substring(0,o),s=t.substring(o+1);n+=e,s&&(r.search=r.search?`${r.search}&${s}`:s)}else n+=t;return r.pathname=n,r.toString()}(i,e)}const{queryParams:a,sequenceParams:l}=function(e,t,r){const n=new Map,o=new Set;if(e.queryParameters?.length)for(const s of e.queryParameters){"Sequence"===s.mapper.type.name&&s.mapper.serializedName&&o.add(s.mapper.serializedName);let i=v(t,s,r);if(null!=i||s.mapper.required){i=e.serializer.serialize(s.mapper,i,M(s));const t=s.collectionFormat?B[s.collectionFormat]:"";if(Array.isArray(i)&&(i=i.map(e=>null==e?"":e)),"Multi"===s.collectionFormat&&0===i.length)continue;!Array.isArray(i)||"SSV"!==s.collectionFormat&&"TSV"!==s.collectionFormat||(i=i.join(t)),s.skipEncoding||(i=Array.isArray(i)?i.map(e=>encodeURIComponent(e)):encodeURIComponent(i)),!Array.isArray(i)||"CSV"!==s.collectionFormat&&"Pipes"!==s.collectionFormat||(i=i.join(t)),n.set(s.mapper.serializedName||M(s),i)}}return{queryParams:n,sequenceParams:o}}(t,r,n);return i=function(e,t,r,n=!1){if(0===t.size)return e;const o=new URL(e),s=function(e){const t=new Map;if(!e||"?"!==e[0])return t;const r=(e=e.slice(1)).split("&");for(const e of r){const[r,n]=e.split("=",2),o=t.get(r);o?Array.isArray(o)?o.push(n):t.set(r,[o,n]):t.set(r,n)}return t}(o.search);for(const[e,o]of t){const t=s.get(e);if(Array.isArray(t))if(Array.isArray(o)){t.push(...o);const r=new Set(t);s.set(e,Array.from(r))}else t.push(o);else t?(Array.isArray(o)?o.unshift(t):r.has(e)&&s.set(e,[t,o]),n||s.set(e,o)):s.set(e,o)}const i=[];for(const[e,t]of s)if("string"==typeof t)i.push(`${e}=${t}`);else if(Array.isArray(t))for(const r of t)i.push(`${e}=${r}`);else i.push(`${e}=${t}`);return o.search=i.length?`?${i.join("&")}`:"",o.toString()}(i,a,l,s),i}(r,t,e,this),o=(0,N.createPipelineRequest)({url:n});o.method=t.httpMethod;const s=A(o);s.operationSpec=t,s.operationArguments=e;const i=t.contentType||this._requestContentType;i&&t.requestBody&&o.headers.set("Content-Type",i);const a=e.options;if(a){const e=a.requestOptions;e&&(e.timeout&&(o.timeout=e.timeout),e.onUploadProgress&&(o.onUploadProgress=e.onUploadProgress),e.onDownloadProgress&&(o.onDownloadProgress=e.onDownloadProgress),void 0!==e.shouldDeserialize&&(s.shouldDeserialize=e.shouldDeserialize),e.allowInsecureConnection&&(o.allowInsecureConnection=!0)),a.abortSignal&&(o.abortSignal=a.abortSignal),a.tracingOptions&&(o.tracingOptions=a.tracingOptions)}this._allowInsecureConnection&&(o.allowInsecureConnection=!0),void 0===o.streamResponseStatusCodes&&(o.streamResponseStatusCodes=function(e){const t=new Set;for(const r in e.responses){const n=e.responses[r];n.bodyMapper&&n.bodyMapper.type.name===$&&t.add(Number(r))}return t}(t));try{const e=await this.sendRequest(o),r=c(e,t.responses[e.status]);return a?.onResponse&&a.onResponse(e,r),r}catch(e){if("object"==typeof e&&e?.response){const r=e.response,n=c(r,t.responses[e.statusCode]||t.responses.default);e.details=n,a?.onResponse&&a.onResponse(r,n,e)}throw e}}}async function T(e){const{scopes:t,response:r}=e,n=e.logger||R,o=r.headers.get("WWW-Authenticate");if(!o)return n.info("The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow."),!1;const s=function(e){return`, ${e.trim()}`.split(", Bearer ").filter(e=>e).map(e=>`${e.trim()}, `.split('", ').filter(e=>e).map(e=>(([e,t])=>({[e]:t}))(e.trim().split('="'))).reduce((e,t)=>({...e,...t}),{}))}(o)||[],i=s.find(e=>e.claims);if(!i)return n.info('The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.'),!1;const a=await e.getAccessToken(i.scope?[i.scope]:t,{claims:(l=i.claims,Buffer.from(l,"base64").toString())});var l;return!!a&&(e.request.headers.set("Authorization",`${a.tokenType??"Bearer"} ${a.token}`),!0)}}};
//# sourceMappingURL=834.extension.js.map